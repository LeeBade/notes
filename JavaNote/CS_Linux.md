# Linux

## 代码风格

### 格式
- 缩进：制表符，8个字符；标注控制块
  - 不要使用空格进行缩进
  - switch函数：将switch和case关键字对齐于一列
- 空格：
  - 行尾不应留下空格
  - 关键字后应添加一个空格
    - 不要在sizeof, typeof, alignof 或者 __attribute__ 这些关键字之后放空格
  - 小括号里的表达式两侧不应添加空格
  - 使用空格，使指针紧靠变量名，与类型分开
    -如： char **ptr
  - 操作符
    - 两元/三元操作符两侧使用一个空格
    - 一元操作符后不要加空格
    - 后缀自加和自减一元操作符前不加空格
    - 前缀自加和自减一元操作符后不加空格
    - . 和 -> 结构体成员操作符前后不加空格。
- 语句长度：限制为80列
  - 将长语句打散为片段，每个片段都应有意义
  - 子片段比母片段短，且靠右
  - ps：仅打散对开发者可见的语句，不打散对用户可见的字符串；
- 大括号
  - 除函数外，起始大括号放在行尾，而把结束大括号放在行首
  - 函数的起始大括号放置于下一行的开头
- 注释仅应说明函数功能
  - <font color=red>永远不要在注释里解释你的代码是如何运作的。如果认为需要注释解释如何工作，那么说明该代码写的很烂</font>；
  - <font color=red>如果需要将注释放在函数体内部，说明该函数过于复杂</font>
  - <font color=red>好的设计应只需要将注释放在函数体外部，仅仅告诉开发者，我做了什么</font>
  - 注释数据；不应用逗号在一行声明多个数据变量；
  - 注释格式
```c
/*
 * This is the preferred style for multi-line
 * comments in the Linux kernel source code.
 * Please use it consistently.
 *
 * Description:  A column of asterisks on the left side,
 * with beginning and ending almost-blank lines.
 */
```

### 命名

- 全局变量：应使用具有描述性的名字
- 本地变量：名字应尽可能短；
  - 只要不引起误解，那么`tmp`可命名任意类型的临时变量
- 函数名标注参数类型无意义，因为编译器会做类型检查

- 数据结构名后缀
  - _t：使用typedef重命名的，不透明的结构体、联合体、枚举、指针等；
  - _head：链表结点
  - _node：树/散列表结点
  - _entry：链表中的节点
  - _lock：锁
  - _bitmap：位图
  - _map：映射结构，通常用于虚拟内存管理
  - _buf：缓冲区结构，通常用于存储和处理数据
  - _cache：缓存结构，用于存储临时数据或提高访问效率
  - _superblock：文件系统的超级块结构

- 只要不是想对开发者隐藏信息，就不应使用typedef为结构体和指针另起一个名字
  - 当对象只能使用函数访问，那么可以使用typedef
    - 例如： pid_t是不透明的，只能使用接口函数访问并修改；后缀_t告知开发者，该数据类型的变量不能直接访问
  - 清楚的整数类型，在某些场合避免使用int、long
    - 例如：u8/u16/u32 
  - 另有其他规则未列出，总而言之，如果一个指针或者一个结构体里的元素可以合理的被直接访问到，那么它们就不应该是一个typedef

```C
typedef <existing_type> <new_type_name>;

\\更清晰的命名风格

struct virtual_container *a;

\\使用typedef隐藏了数据类型信息

typedef virtual_container vps_t

vps_t *a；

```

- 用于定义常量的宏的名字及枚举里的标签需要大写

```c

#define CONSTANT 0x12345

```

- 使用枚举定义多个相关常量

### 函数

- 函数代码长度与复杂度成反比；
- 拆分复杂的、冗长的、本地变量引用过多的函数
  - 如果性能是要求的，那么可以内联这些函数
- 如果该函数需要被导出，它的 EXPORT 宏 应该紧贴在它的结束大括号之下
- goto：无条件跳转语句
  - 减少嵌套程度，让编译器省去删除冗余代码；
  - 在退出标签处执行一些工作；
    - 如果没有可以放在标签处执行的工作，那么函数return即可；
  - goto容易跟踪测试，避免修改深层嵌套函数时因忘记更新某些点而导致错误
  - 标签名应说明goto的行为以及效果
- 返回值
  - 若函数是动作或命令，该函数返回错误代码整数
    - 0成功，非0失败
  - 若函数是判断，该函数返回布尔值
    - 0假，非0真
  - 返回值是实际计算结果而不是计算是否成功的标志的函数不受此惯例的限制
    - 返回指针的函数， 他们使用 NULL 或者 ERR_PTR 机制来报告错误

## 设计

### 引用计数器

- 若某个数据，对创建和销毁该数据的单线程之外的线程可见，那么该数据必须要有一个引用计数器，避免在内核设计垃圾收集这种低效率配件；
- 引用计数避免上锁，允许多线程并行访问某数据
    - 上锁：保持数据一致性
    - 引用计数：内存管理
- 多级引用计数：子类计数器统计子类用户的数量；每当子类计数器减至零，该子类计数器的父类计数器减一；使用多级引用计数的数据结构有
      - 内存管理struct mm_struct: mm_users 和 mm_count
      - 文件系统 struct super_block: s_count 和 s_active
- bug：另一个执行线索可以找到某数据结构，但这个数据结构没有引用计数器

### 内核消息

- 内核消息
  - 规范书写，避免不规范的单词
  - 检查消息是否匹配宏

```c
  
  if ((pid = fork()) < 0) {
		fprintf(stderr, "fork error: %s\n", strerror(errno));
		exit(0);
	}

```
- errno：线程本地变量，存储与系统调用和库函数调用相关的错误代码
  - 整型，<errno.h>定义其含义，可通过函数接口打印；可能使用errno的函数有
  - 系统调用：
    - open()、read()、write()、close()、fork()、exec()等
  - 标准库函数：
    - malloc()、free()、fopen()、fclose()、printf()、scanf()等
  - 网络库函数：
    - socket()、bind()、listen()、accept()、connect()、send()、recv()等
  - 文件操作函数：
    - fopen()、fwrite()、fread()、fprintf()、fscanf()等

