# 数据结构与算法的世界

## 绪论
- 确定数据集，权衡对程序运行时间的要求以及开发时间
  - 程序需要大量输入时，估计该程序的运行时间；
  - 在未具体编码前，比较两个程序的运行时间
  - 确定限制程序瓶颈的代码段，并彻底改进程序速度；
- 级数
  - $\sum_{i=0}^N 2^i=2^{N+1}-1$
  - $\sum_{i=0}^N A^i=\frac{A^{N+1}-1}{A-1}$
    - $\sum_{i=0}^N A^i \leqslant \frac{1}{1-A}，0<A<1$
    - $\lim \limits_{N \to ∞}{\sum_{i=0}^N A^i}=\frac{1}{1-A}$
  - $\sum_{i=1}^N i^2=\frac{N(N+1)(2 N+1)}{6} \approx \frac{N^3}{3}$
  - $\sum_{i=1}^N i^k \approx \frac{N^{k+1}}{|k+1|} ; \quad k \neq-1$
    - $k=-1$时，上述公式不成立，使用以下公式计算调和数的和(记为$H_N$)
    - $H_N=\sum_{i=1}^N \frac{1}{i} \approx \log _e N$
- 模运算：$A \equiv B(\bmod N)$
    - $N$整除$A-B$
    - $A\%N==B\%N$
    - $A$与$B$模$N$同余
- 归纳法：
  - 证明基准情形
  - 进行归纳假设
- 反证法

## 递归

- 正确的递归
  - 处理基准情形：不需要递归调用就可以返回；
  - 不断推进：不断递归调用直到处理基准情形；
- 错误的递归：形成循环
  - 例如节点自循环：不断地调用自己传递相同的参数；
- 函数PrintDigit接收个位数并打印它；设计递归函数打印正整数；
  - 先打印非个位数，然后打印个位数；
  - 如果非个位数大于10，那么打印非个位数只需要调用本方法
```java

private static void PrintOut (int x) {
    if (x > 9)
        PrintOut (x / 10);
    else {
        System.out.println (x%10);
    }
}

```

- 设计递归：将问题拆解为基准情形与非基准情形；非基准情形使用递归求解；
- 检查设计是否满足递归法则
  - 基准情形：不使用递归就可以求解
  - 不断推进：非基准情形在使用递归调用时必须朝产生基准情形的方向推进
  - 设计法则：假设所有的递归调用都能运行
  - 合成效益法则：在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性的工作。

## 算法分析